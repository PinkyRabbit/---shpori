# Модель рабочего пространства GitFlow
Репозиторий обязан иметь **две** основные ветки:
1. **Master** - наиболее стабильная ветвь, которая всегда находится в состоянии "готов к запуску", содержит самую последнюю **рабочую** версию
2. **Develop** - производная от _master_. Ветка для разработки, которая служит для интегрирования различных фич, которые планируются в будующем релизе. Эта ветвь может быть не такой стабильной, как ветка _master_. Это место, где все разработчики взаимодействуют друг с другом, раскидывая наработки по другим веткам.
С этих двух веток начинается проект. Они **обе должны быть защищены** против внезапного удаления. Поэтому только лидер проекта должен иметь доступ их мержить.

> Важно заметить! Постоянно держите глаз на том, что кодим мы только или в ветке develop, или в её детях!! В Мастере мы не кодим!!!

Кроме этого, у нормального рабочего пространства могут быть следующие ветки:
* **Feature** - ветвится от ветки _develop_ и служит для различных фич.
* **Release** - так же ветвится от ветки _develop_, но служит для релизов.
* **Hotfix** - ветвится от ветки _master_ и служит для быстрого исправления багов, обнаруженных при выпуске новой версии.

## Запуск GitFlow
Ссылка на [GitFlow](https://github.com/nvie/gitflow). Если надо, там полно инструкций по установке.

Организуем проект GitFlow в три шага:
1. Клонируем репозиторий нашего проекта или что-то такое
2. Переходим в папку с проектом
3. Инициализируем flow с помощью команды `git flow init`

После этого выскочат парочку вопросиков, там всё понятно.

## Ветви _master_ и _develop_
После активации flow наши ветви пропадают. Нужно их создать заново и запушить в репозиторий.

Для того, чтобы переключиться на ветку _master_ нужно сделать
```
git checkout master
```
После переключения можно её запушить
```
git push -u origin master
```
То же самое и с веткой _develop_. Пока что она только лишь на локальном репозитории на компе.
```
git checkout develop
git push origin develop
```
Теперь у нас репозиторий с обеими ветками. Стоит заметить, что это разумно, если начинать проект "с нуля". Если у вас уже много кода - достаточно и одной ветки _master_.

## Ветка Feature
По-умолчанию имя ветки (или веток) с фичами начинается на `feature`. Суть в том, что тут девелоперы взаимодействуют над конкретными задачами. Обычно это что-то небольшое, что можно уместить в слово "модуль". В отдельную ветку фичи складываются потому, что, часто бывает такое, что фичи оказываются нецелесообразными и отбрасываются, или же, банально, не своевременными, и тормозят развитие проекта. Поэтому их откладывают и берутся за новую фичу. Жизненный цикл ветки с фичей заканчивается, когда эта фича вливается в ветку _develop_ (то есть, мержится с ней).

#### Пример:
Начинаем ветку с фичей. Назовём её `feature1`

```
git flow feature start feature1
```
Всё, фича существует! Но только на нашем компе. Это значит, что пока мы не мешаем никому вообще. Мы спокойно себе кодим до результата. Как только фича готова - делаем коммит и можем запушить её в основной репозиторий.

Проверяем статус и коммитим:
```
git status
git add .
git commit -am "Your message"
```
Публикуем нашу фичу на GitHub.com
```
git flow publish feature1
git push
```
Если проверите репозиторий, то обнаружите ветку `feature/feature1`. Всё потому что gitflow добавил feature автоматом.
> Если над фичей будет работать несколько человек, смысл остаётся такой же, но, при этом, кто-то из них создаёт пустую ветку под фичу, чтобы остальные могли её скачать. В остальном, работа как обычно. Чтобы подключиться к уже созданной фиче используется команда `git flow feature track feature1`

Когда код был проверен, а фича - одобрена, её сливают с веткой _develop_. При этом ветка с фичей автоматом разрушается на GitHub.
```
git flow finish feature1
```
#### Удалить x_x
Ветку всегда можно удалить c помощью команды `-d`
```
git branch -d feature/feature1
```

### Чужой репозиторий
> Сперва проверьте, есть ли ветка `develop` на чужом репозитории

Если репозиторий чужой, прежде чем создавать пространство под фичи, нужно его клонировать и инициализировать флоу:
```
git clone https://github.com/bharatdwarkani/gitflow-example.git
cd gitflow-example
git checkout develop
git flow init
```
## Ветка Release
Ветка релиза запускается с ветки _develop_ и, после, сливается обратно в ветки _develop_ и _master_, что означает завершение релиза. По негласному соглашению имеет вид `release/*`. Эта ветвь запускается, когда фичи доделаны и новый релиз готов к выходу.

Возникает логичный вопрос - почему нельзя запускать релизы с ветки _develop_ напрямую? Суть в том, что, например, над проектом работает 100 человек. Если вы решили выпустить обнову - они не могут выливать новые вещи(фичи) в _develop_ пока вы не выкинете их в новую версию. Иначе это просто будет непроверенный код и бедлам. А здесь - спокойно создаётся ветка отдельная и в ней всё подготавливается к релизу. При этом _develop_ может спокойно себе развиваться как раньше. А мы, в релизе, чётко понимаем, какие у нас фичи добавлены, что нужно оттестировать и тп. К слову сказать, тесты лучше запускать всё таки на ветке _develop_.

Жизнь ветки _release_ заканчивается, когда она сливается с ветками _develop_ и _master_, что означает выход релиза. После этого она может быть удалена (но не обязательно). И после этого вы можете приклеить `tag` на ветку _master_. Обычно это что-то типа `v1.0.0`

### Пример:
Переходим в ветку _develop_, *если нужно* делаем `pull` и начинаем новый релиз:
```
git checkout develop
git pull
git flow release start release1
```
Добавляем все наши фишки, коммитим их и публикуем релиз.
```
git add .
git commit -am "Your message"
git flow publish release1
git push
```
Всё. Релиз опубликован. Можно смотреть в репозиторий.

#### Теперь сливаем наши ветки _develop_ и _master_
Сперва _develop_:
```
git checkout develop
git merge release/release1
```
Потом _master_:
```
git checkout release/release1
git pull
git flow release finish release1
```
Это делает то же самое по сути, но мне нравится больше:
```
git flow release finish -m "Your message" "release1"
git checkout master
git push --all origin
```
## Ветка Hotfix
